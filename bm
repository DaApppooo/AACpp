#!/bin/env python3
# Bullshit make
from os import listdir, path, remove, stat, system, rename, makedirs
import re
from sys import argv
from json import load, dump

FLAG_DEBUG = 0
VERBOSE = True
CC = "g++"
SRC_PATH = "src"
CFLAGS = f"-I {SRC_PATH} -g -export-dynamic" + ("" if not FLAG_DEBUG else " -D DEBUG")
LFLAGS = "-lraylib -lGL -lm -lpthread -ldl -lrt -lX11 `pkg-config --cflags --libs gtk+-2.0` -L lib -lnfd"
OBJ_PATH = "temp"
BIN = "bin/aac" # Bin path is deduced from this.
CONFIG = "config/bm.json" # Same here
EXT = ".cpp"
EXAMPLE = "./bin/aac"

def rls(path_, filter = lambda x: True):
	for target in listdir(path_):
		target = f"{path_}/{target}"
		if path.isdir(target):
			for ret in rls(target, filter):
				yield ret
		else:
			if filter(target):
				yield target
def last_ch(path: str):
	return stat(path).st_mtime
def load_opt():
	global opt
	try:
		with open(CONFIG, "r") as f:
			opt = load(f)
	except FileNotFoundError:
		print("[bm] Failed to open options.")
		opt = {}
def save_opt():
	global opt
	with open(CONFIG, "w") as f:
		dump(opt, f)
def yeet(code: int):
	save_opt()
	print(f"Exited with code {(code>>8)&0xff}")
	quit(code)
def fixmissing_files_opt():
	for path_ in rls(
		SRC_PATH,
		lambda p:
			p[-len(EXT):] == EXT
		and p not in opt
	):
		# Iter through all source .cpp files and check if there are any missing in the options
		if path_ not in opt:
			opt[path_] = last_ch(path_)
def compile_all(check_ch_time = True, cflags = ""):
	for path_ in rls(
		SRC_PATH,
		lambda p:
			p[-len(EXT):] == EXT
	):
		# Iter through all source .cpp files
		if (not check_ch_time) or opt[path_] < last_ch(path_):
			compile_to_obj(path_, cflags)
def compile_to_obj(p: str, cflags=""):
	""" cflags are additional flags to the setting CFLAGS """
	out_path = f"{OBJ_PATH}/{path.basename(p)}"[:-len(EXT)] + '.o'
	if code := shell(f"{CC} -c {p} -o {out_path} {CFLAGS} {cflags}"):
		yeet(code)
	else:
		opt[p] = last_ch(p)
def link_all(cflags = ""):
	""" cflags are additional flags to the setting CFLAGS """
	j = " ".join(rls(OBJ_PATH, lambda x: x[-2:] == ".o"))
	if not j:
		raise Exception("Wtf ???")
	if code := shell(f"{CC} {j} -o {BIN} {CFLAGS} {cflags} {LFLAGS}"):
		yeet(code)
def run_example():
	if code := shell(EXAMPLE):
		yeet(code)
def debugging(tool: str):
	match tool:
		case "valgrind" | "mem" | "v":
			if code := shell(f"valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes -s -- {BIN} examples/test.da"):
				yeet(code)
		# add more tools here
		case _:
			if code := shell(f"gdb {BIN}"):
				yeet(code)

if VERBOSE:
	def shell(cmd: str) -> int:
		print(cmd)
		return system(cmd)
else:
	shell = system

if not path.exists(OBJ_PATH):
	makedirs(OBJ_PATH, exist_ok=True)
BIN_PATH = BIN.rsplit('/', 1)[0]
if not path.exists(BIN_PATH):
	makedirs(BIN_PATH, exist_ok=True)
CONFIG_PATH = CONFIG.rsplit('/', 1)[0]
if not path.exists(CONFIG_PATH):
	makedirs(CONFIG_PATH, exist_ok=True)

load_opt()
fixmissing_files_opt()
if __name__ == "__main__":
	if len(argv) == 1:
		compile_all(cflags="-O0") # Avoid any optimization for a simple test run
		link_all()
		run_example()
		yeet(0)

	match argv[1]:
		case "all":
			compile_all(check_ch_time=False, cflags="-O0")
			yeet(0)
		case "production":
			compile_all(check_ch_time=False, cflags="-O3")
			link_all()
			yeet(0)
		case "dbg" | "gdb" | "debug" | "d" | "fd":
			# 'fd' is fast debug (won't recompile everything)
			if argv[1] != "fd":
				shell("./bm all")
			link_all(cflags="-O0")
			debugging("" if len(argv) == 2 else argv[2])
			yeet(0)
		case "clear" | "clean":
			shell("rm temp/*")
			yeet(0)
		case "copy":
			if err := shell(f"cp {__file__} ."):
				yeet(err)
			yeet(0)
		case _:
			print("Syntax: bm [arg]")
			print("\targ can either be 'c', 'all', 'dbg', 'clean', 'copy', or 'production'")

